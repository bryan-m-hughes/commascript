"use strict";
Object.defineProperties(exports, {
  isCommaScriptDirective: {get: function() {
      return isCommaScriptDirective;
    }},
  registerNodeProcessor: {get: function() {
      return registerNodeProcessor;
    }},
  processNode: {get: function() {
      return processNode;
    }},
  processBlock: {get: function() {
      return processBlock;
    }},
  __esModule: {value: true}
});
var $__state__;
var $__0 = ($__state__ = require("./state"), $__state__ && $__state__.__esModule && $__state__ || {default: $__state__}),
    handleInternalError = $__0.handleInternalError,
    getState = $__0.getState,
    states = $__0.states;
var processors = {};
function isCommaScriptDirective(node) {
  return node.type == 'ExpressionStatement' && node.expression.type == 'Literal' && node.expression.value == 'use commascript';
}
function registerNodeProcessor(processor) {
  processors[processor.name] = processor;
}
function processNode(node) {
  var processor = processors[node.type];
  if (!processor) {
    handleInternalError('No processor for rule type ' + node.type);
  }
  switch (getState()) {
    case states.SCANNING:
      return processor.scan(node);
    case states.PARSING_STATEMENT:
      return processor.parseStatement(node);
    case states.PARSING_EXPRESSION:
      return processor.parseExpression(node);
    case states.DECLARING:
      return processor.declare(node);
    default:
      handleInternalError('Unknown or invalid state ' + getState() + ' in processNode');
  }
}
function processBlock(nodes) {
  if (nodes) {
    switch (getState()) {
      case states.SCANNING:
        for (var i = 0,
            len = nodes.length; i < len; i++) {
          processNode(nodes[i].analyze());
        }
        break;
      case states.PARSING_STATEMENT:
        for (var i = 0,
            len = nodes.length; i < len; i++) {
          var result = processNode(nodes[i]);
          if (result.result == 'return' || result.result == 'throw' || result.result == 'break' || result.result == 'continue') {
            return result;
          }
        }
        break;
      default:
        handleInternalError('Unknown or invalid state ' + getState() + ' in processBlock');
    }
  }
  return {result: 'normal'};
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGUuanMiLCJAdHJhY2V1ci9nZW5lcmF0ZWQvVGVtcGxhdGVQYXJzZXIvNiIsIkB0cmFjZXVyL2dlbmVyYXRlZC9UZW1wbGF0ZVBhcnNlci80IiwiQHRyYWNldXIvZ2VuZXJhdGVkL1RlbXBsYXRlUGFyc2VyLzEiLCJAdHJhY2V1ci9nZW5lcmF0ZWQvVGVtcGxhdGVQYXJzZXIvMiIsIkB0cmFjZXVyL2dlbmVyYXRlZC9UZW1wbGF0ZVBhcnNlci81IiwiQHRyYWNldXIvZ2VuZXJhdGVkL1RlbXBsYXRlUGFyc2VyLzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0JBO0FDeEJBLEtBQUssaUJBQWlCLEFBQUMsQ0FBQyxPQUFNO3dCQ0E5QixFQUFDLEdBQUUsWUNBcUI7QUFBRSxtQ0FBd0I7SUFBRSxBREE5QixDQUFDO3VCQUF2QixFQUFDLEdBQUUsWUNBcUI7QUFBRSxrQ0FBd0I7SUFBRSxBREE5QixDQUFDO2FBQXZCLEVBQUMsR0FBRSxZQ0FxQjtBQUFFLHdCQUF3QjtJQUFFLEFEQTlCLENBQUM7Y0FBdkIsRUFBQyxHQUFFLFlDQXFCO0FBQUUseUJBQXdCO0lBQUUsQURBOUIsQ0FBQztBRUF2QixXQUFTLENDQVQsRUFBQyxLQUFJLENEQU8sS0FBRyxBQ0FTLENBQUM7Q0pBeUIsQ0FBQzs7U0tBbkQsRUFBQyxZQUFvQixDQUFBLE9BQU0sQUFBQyxXQUFrQixDQUN0QyxDQUFBLGFBQXFCLHNCQUEyQixDQUFBLGFBQXFCLEdBQUssRUFBQyxPQUFNLFlBQW1CLENBRDlELEFBQytELENBQUM7QU51QnJHLHNCQUFrQjtBQUFHLFdBQU87QUFBRyxTQUFLO0FBRTdDLEFBQUksRUFBQSxDQUFBLFVBQVMsRUFBSSxHQUFDLENBQUM7QUFFWixPQUFTLHVCQUFxQixDQUFFLElBQUcsQ0FBRztBQUMzQyxPQUFPLENBQUEsSUFBRyxLQUFLLEdBQUssc0JBQW9CLENBQUEsRUFDdEMsQ0FBQSxJQUFHLFdBQVcsS0FBSyxHQUFLLFVBQVEsQ0FBQSxFQUNoQyxDQUFBLElBQUcsV0FBVyxNQUFNLEdBQUssa0JBQWdCLENBQUM7QUFDOUM7QUFBQSxBQUVPLE9BQVMsc0JBQW9CLENBQUUsU0FBUSxDQUFHO0FBQy9DLFdBQVMsQ0FBRSxTQUFRLEtBQUssQ0FBQyxFQUFJLFVBQVEsQ0FBQztBQUN4QztBQUFBLEFBRU8sT0FBUyxZQUFVLENBQUUsSUFBRyxDQUFHO0FBQ2hDLEFBQUksSUFBQSxDQUFBLFNBQVEsRUFBSSxDQUFBLFVBQVMsQ0FBRSxJQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLEtBQUksQ0FBQyxTQUFRLENBQUc7QUFDZCxzQkFBa0IsQUFBQyxDQUFDLDZCQUE0QixFQUFJLENBQUEsSUFBRyxLQUFLLENBQUMsQ0FBQztFQUNoRTtBQUFBLEFBQ0EsU0FBUSxRQUFPLEFBQUMsRUFBQztBQUNmLE9BQUssQ0FBQSxNQUFLLFNBQVM7QUFDakIsV0FBTyxDQUFBLFNBQVEsS0FBSyxBQUFDLENBQUMsSUFBRyxDQUFDLENBQUM7QUFBQSxBQUM3QixPQUFLLENBQUEsTUFBSyxrQkFBa0I7QUFDMUIsV0FBTyxDQUFBLFNBQVEsZUFBZSxBQUFDLENBQUMsSUFBRyxDQUFDLENBQUM7QUFBQSxBQUN2QyxPQUFLLENBQUEsTUFBSyxtQkFBbUI7QUFDM0IsV0FBTyxDQUFBLFNBQVEsZ0JBQWdCLEFBQUMsQ0FBQyxJQUFHLENBQUMsQ0FBQztBQUFBLEFBQ3hDLE9BQUssQ0FBQSxNQUFLLFVBQVU7QUFDbEIsV0FBTyxDQUFBLFNBQVEsUUFBUSxBQUFDLENBQUMsSUFBRyxDQUFDLENBQUM7QUFBQSxBQUNoQztBQUNFLHdCQUFrQixBQUFDLENBQUMsMkJBQTBCLEVBQUksQ0FBQSxRQUFPLEFBQUMsRUFBQyxDQUFBLENBQUksa0JBQWdCLENBQUMsQ0FBQztBQUQ1RSxFQUVUO0FBQ0Y7QUFBQSxBQUVPLE9BQVMsYUFBVyxDQUFFLEtBQUksQ0FBRztBQUNsQyxLQUFJLEtBQUksQ0FBRztBQUNULFdBQU8sUUFBTyxBQUFDLEVBQUM7QUFDZCxTQUFLLENBQUEsTUFBSyxTQUFTO0FBQ2pCLFlBQVMsR0FBQSxDQUFBLENBQUEsRUFBSSxFQUFBO0FBQUcsY0FBRSxFQUFJLENBQUEsS0FBSSxPQUFPLENBQUcsQ0FBQSxDQUFBLEVBQUksSUFBRSxDQUFHLENBQUEsQ0FBQSxFQUFFLENBQUc7QUFDaEQsb0JBQVUsQUFBQyxDQUFDLEtBQUksQ0FBRSxDQUFBLENBQUMsUUFBUSxBQUFDLEVBQUMsQ0FBQyxDQUFDO1FBQ2pDO0FBQUEsQUFDQSxhQUFLO0FBQUEsQUFDUCxTQUFLLENBQUEsTUFBSyxrQkFBa0I7QUFDMUIsWUFBUyxHQUFBLENBQUEsQ0FBQSxFQUFJLEVBQUE7QUFBRyxjQUFFLEVBQUksQ0FBQSxLQUFJLE9BQU8sQ0FBRyxDQUFBLENBQUEsRUFBSSxJQUFFLENBQUcsQ0FBQSxDQUFBLEVBQUUsQ0FBRztBQUNoRCxBQUFJLFlBQUEsQ0FBQSxNQUFLLEVBQUksQ0FBQSxXQUFVLEFBQUMsQ0FBQyxLQUFJLENBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBQztBQUNsQyxhQUFJLE1BQUssT0FBTyxHQUFLLFNBQU8sQ0FBQSxFQUFLLENBQUEsTUFBSyxPQUFPLEdBQUssUUFBTSxDQUFBLEVBQUssQ0FBQSxNQUFLLE9BQU8sR0FBSyxRQUFNLENBQUEsRUFBSyxDQUFBLE1BQUssT0FBTyxHQUFLLFdBQVMsQ0FBRztBQUNwSCxpQkFBTyxPQUFLLENBQUM7VUFDZjtBQUFBLFFBQ0Y7QUFBQSxBQUNBLGFBQUs7QUFBQSxBQUNUO0FBQ0UsMEJBQWtCLEFBQUMsQ0FBQywyQkFBMEIsRUFBSSxDQUFBLFFBQU8sQUFBQyxFQUFDLENBQUEsQ0FBSSxtQkFBaUIsQ0FBQyxDQUFDO0FBRDdFLElBRVA7RUFDRjtBQUFBLEFBQ0EsT0FBTyxFQUNMLE1BQUssQ0FBRyxTQUFPLENBQ2pCLENBQUM7QUFDSDtBQUFBIiwiZmlsZSI6Im5vZGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxMy0yMDE0IEJyeWFuIEh1Z2hlcyA8YnJ5YW5AdGhlb3JldGljYWxpZGVhdGlvbnMuY29tPiAoaHR0cDovL3RoZW9yZXRpY2FsaWRlYXRpb25zLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxuaW1wb3J0IHsgaGFuZGxlSW50ZXJuYWxFcnJvciwgZ2V0U3RhdGUsIHN0YXRlcyB9IGZyb20gJy4vc3RhdGUnO1xuXG52YXIgcHJvY2Vzc29ycyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb21tYVNjcmlwdERpcmVjdGl2ZShub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICYmXG4gICAgbm9kZS5leHByZXNzaW9uLnR5cGUgPT0gJ0xpdGVyYWwnICYmXG4gICAgbm9kZS5leHByZXNzaW9uLnZhbHVlID09ICd1c2UgY29tbWFzY3JpcHQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJOb2RlUHJvY2Vzc29yKHByb2Nlc3Nvcikge1xuICBwcm9jZXNzb3JzW3Byb2Nlc3Nvci5uYW1lXSA9IHByb2Nlc3Nvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5vZGUpIHtcbiAgdmFyIHByb2Nlc3NvciA9IHByb2Nlc3NvcnNbbm9kZS50eXBlXTtcbiAgaWYgKCFwcm9jZXNzb3IpIHtcbiAgICBoYW5kbGVJbnRlcm5hbEVycm9yKCdObyBwcm9jZXNzb3IgZm9yIHJ1bGUgdHlwZSAnICsgbm9kZS50eXBlKTtcbiAgfVxuICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICBjYXNlIHN0YXRlcy5TQ0FOTklORzpcbiAgICAgIHJldHVybiBwcm9jZXNzb3Iuc2Nhbihub2RlKTtcbiAgICBjYXNlIHN0YXRlcy5QQVJTSU5HX1NUQVRFTUVOVDpcbiAgICAgIHJldHVybiBwcm9jZXNzb3IucGFyc2VTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBzdGF0ZXMuUEFSU0lOR19FWFBSRVNTSU9OOlxuICAgICAgcmV0dXJuIHByb2Nlc3Nvci5wYXJzZUV4cHJlc3Npb24obm9kZSk7XG4gICAgY2FzZSBzdGF0ZXMuREVDTEFSSU5HOlxuICAgICAgcmV0dXJuIHByb2Nlc3Nvci5kZWNsYXJlKG5vZGUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBoYW5kbGVJbnRlcm5hbEVycm9yKCdVbmtub3duIG9yIGludmFsaWQgc3RhdGUgJyArIGdldFN0YXRlKCkgKyAnIGluIHByb2Nlc3NOb2RlJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NCbG9jayhub2Rlcykge1xuICBpZiAobm9kZXMpIHtcbiAgICBzd2l0Y2goZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSBzdGF0ZXMuU0NBTk5JTkc6XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHByb2Nlc3NOb2RlKG5vZGVzW2ldLmFuYWx5emUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0YXRlcy5QQVJTSU5HX1NUQVRFTUVOVDpcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHByb2Nlc3NOb2RlKG5vZGVzW2ldKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PSAncmV0dXJuJyB8fCByZXN1bHQucmVzdWx0ID09ICd0aHJvdycgfHwgcmVzdWx0LnJlc3VsdCA9PSAnYnJlYWsnIHx8IHJlc3VsdC5yZXN1bHQgPT0gJ2NvbnRpbnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGhhbmRsZUludGVybmFsRXJyb3IoJ1Vua25vd24gb3IgaW52YWxpZCBzdGF0ZSAnICsgZ2V0U3RhdGUoKSArICcgaW4gcHJvY2Vzc0Jsb2NrJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiAnbm9ybWFsJ1xuICB9O1xufVxuIiwiT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXhwb3J0cywgJF9fcGxhY2Vob2xkZXJfXzApOyIsIntnZXQ6ICRfX3BsYWNlaG9sZGVyX18wfSIsImdldCAkX19wbGFjZWhvbGRlcl9fMCgpIHsgcmV0dXJuICRfX3BsYWNlaG9sZGVyX18xOyB9IiwiX19lc01vZHVsZTogdHJ1ZSIsInt2YWx1ZTogJF9fcGxhY2Vob2xkZXJfXzB9IiwiKCRfX3BsYWNlaG9sZGVyX18wID0gcmVxdWlyZSgkX19wbGFjZWhvbGRlcl9fMSksIFxuICAgICAgICAkX19wbGFjZWhvbGRlcl9fMiAmJiAkX19wbGFjZWhvbGRlcl9fMy5fX2VzTW9kdWxlICYmICRfX3BsYWNlaG9sZGVyX180IHx8IHtkZWZhdWx0OiAkX19wbGFjZWhvbGRlcl9fNX0pIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9