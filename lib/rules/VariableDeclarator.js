"use strict";
var $___46__46__47_node__,
    $___46__46__47_state__,
    $___46__46__47_type__;
var $__0 = ($___46__46__47_node__ = require("../node"), $___46__46__47_node__ && $___46__46__47_node__.__esModule && $___46__46__47_node__ || {default: $___46__46__47_node__}),
    registerNodeProcessor = $__0.registerNodeProcessor,
    processNode = $__0.processNode;
var $__1 = ($___46__46__47_state__ = require("../state"), $___46__46__47_state__ && $___46__46__47_state__.__esModule && $___46__46__47_state__ || {default: $___46__46__47_state__}),
    addNamedType = $__1.addNamedType,
    enterState = $__1.enterState,
    exitState = $__1.exitState,
    states = $__1.states,
    handleError = $__1.handleError,
    handleInternalError = $__1.handleInternalError;
var isNull = ($___46__46__47_type__ = require("../type"), $___46__46__47_type__ && $___46__46__47_type__.__esModule && $___46__46__47_type__ || {default: $___46__46__47_type__}).isNull;
registerNodeProcessor({
  name: 'VariableDeclarator',
  parseStatement: function(node) {
    switch (node.id.type) {
      case 'Identifier':
        if (!node.init) {
          handleError(node, 'Variable declarations must have an initializer');
        } else {
          enterState(states.PARSING_EXPRESSION);
          var type = processNode(node.init);
          if (isNull(type)) {
            handleError(node, 'Cannot initialize variables to "null" because it is ambiguous.' + ' Try casting null to a named type?');
          } else {
            addNamedType(node.id.name, type);
          }
          exitState();
        }
        break;
      case 'ObjectPattern':
        throw new Error('Not Implemented');
        break;
      case 'ArrayPattern':
        throw new Error('Not Implemented');
        break;
      default:
        handleInternalError('Unknown pattern type ' + node.type);
    }
    return {result: 'normal'};
  },
  scan: function(node) {
    throw new Error('Not Implemented');
  }
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJ1bGVzL1ZhcmlhYmxlRGVjbGFyYXRvci5qcyIsIkB0cmFjZXVyL2dlbmVyYXRlZC9UZW1wbGF0ZVBhcnNlci8wIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdCQTs7OztTQ3hCQSxFQUFDLHVCQUFvQixDQUFBLE9BQU0sQUFBQyxXQUFrQixDQUN0QyxDQUFBLHdCQUFxQixpQ0FBMkIsQ0FBQSx3QkFBcUIsR0FBSyxFQUFDLE9BQU0sdUJBQW1CLENBRDlELEFBQytELENBQUM7QUR1QnJHLHdCQUFvQjtBQUFHLGNBQVU7U0N4QjFDLEVBQUMsd0JBQW9CLENBQUEsT0FBTSxBQUFDLFlBQWtCLENBQ3RDLENBQUEseUJBQXFCLGtDQUEyQixDQUFBLHlCQUFxQixHQUFLLEVBQUMsT0FBTSx3QkFBbUIsQ0FEOUQsQUFDK0QsQ0FBQztBRHdCckcsZUFBVztBQUFHLGFBQVM7QUFBRyxZQUFRO0FBQUcsU0FBSztBQUFHLGNBQVU7QUFBRyxzQkFBa0I7RUFDNUUsT0FBSyxFQzFCZCxFQUFDLHVCQUFvQixDQUFBLE9BQU0sQUFBQyxXQUFrQixDQUN0QyxDQUFBLHdCQUFxQixpQ0FBMkIsQ0FBQSx3QkFBcUIsR0FBSyxFQUFDLE9BQU0sdUJBQW1CLENBRDlELEFBQytELENBQUM7QUQyQjlHLG9CQUFvQixBQUFDLENBQUM7QUFFcEIsS0FBRyxDQUFHLHFCQUFtQjtBQUV6QixlQUFhLENBQWIsVUFBZSxJQUFHLENBQUc7QUFFbkIsV0FBTyxJQUFHLEdBQUcsS0FBSztBQUNoQixTQUFLLGFBQVc7QUFDZCxXQUFJLENBQUMsSUFBRyxLQUFLLENBQUc7QUFDZCxvQkFBVSxBQUFDLENBQUMsSUFBRyxDQUFHLGlEQUErQyxDQUFDLENBQUM7UUFDckUsS0FBTztBQUNMLG1CQUFTLEFBQUMsQ0FBQyxNQUFLLG1CQUFtQixDQUFDLENBQUM7QUFDckMsQUFBSSxZQUFBLENBQUEsSUFBRyxFQUFJLENBQUEsV0FBVSxBQUFDLENBQUMsSUFBRyxLQUFLLENBQUMsQ0FBQztBQUNqQyxhQUFJLE1BQUssQUFBQyxDQUFDLElBQUcsQ0FBQyxDQUFHO0FBQ2hCLHNCQUFVLEFBQUMsQ0FBQyxJQUFHLENBQUcsQ0FBQSxnRUFBK0QsRUFDL0UscUNBQW1DLENBQUMsQ0FBQztVQUN6QyxLQUFPO0FBQ0wsdUJBQVcsQUFBQyxDQUFDLElBQUcsR0FBRyxLQUFLLENBQUcsS0FBRyxDQUFDLENBQUM7VUFDbEM7QUFBQSxBQUNBLGtCQUFRLEFBQUMsRUFBQyxDQUFDO1FBQ2I7QUFBQSxBQUNBLGFBQUs7QUFBQSxBQUNQLFNBQUssZ0JBQWM7QUFDakIsWUFBTSxJQUFJLE1BQUksQUFBQyxDQUFDLGlCQUFnQixDQUFDLENBQUM7QUFDbEMsYUFBSztBQUFBLEFBQ1AsU0FBSyxlQUFhO0FBQ2hCLFlBQU0sSUFBSSxNQUFJLEFBQUMsQ0FBQyxpQkFBZ0IsQ0FBQyxDQUFDO0FBQ2xDLGFBQUs7QUFBQSxBQUNQO0FBQ0UsMEJBQWtCLEFBQUMsQ0FBQyx1QkFBc0IsRUFBSSxDQUFBLElBQUcsS0FBSyxDQUFDLENBQUM7QUFEbkQsSUFFVDtBQUNBLFNBQU8sRUFDTCxNQUFLLENBQUcsU0FBTyxDQUNqQixDQUFDO0VBQ0g7QUFFQSxLQUFHLENBQUgsVUFBSyxJQUFHLENBQUc7QUFDVCxRQUFNLElBQUksTUFBSSxBQUFDLENBQUMsaUJBQWdCLENBQUMsQ0FBQztFQUNwQztBQUFBLEFBRUYsQ0FBQyxDQUFDO0FBQ0YiLCJmaWxlIjoicnVsZXMvVmFyaWFibGVEZWNsYXJhdG9yLmpzIiwic291cmNlUm9vdCI6Ii4uIiwic291cmNlc0NvbnRlbnQiOlsiLypcblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBCcnlhbiBIdWdoZXMgPGJyeWFuQHRoZW9yZXRpY2FsaWRlYXRpb25zLmNvbT4gKGh0dHA6Ly90aGVvcmV0aWNhbGlkZWF0aW9ucy5jb20pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cbiovXG5cbmltcG9ydCB7IHJlZ2lzdGVyTm9kZVByb2Nlc3NvciwgcHJvY2Vzc05vZGUgfSBmcm9tICcuLi9ub2RlJztcbmltcG9ydCB7IGFkZE5hbWVkVHlwZSwgZW50ZXJTdGF0ZSwgZXhpdFN0YXRlLCBzdGF0ZXMsIGhhbmRsZUVycm9yLCBoYW5kbGVJbnRlcm5hbEVycm9yIH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSAnLi4vdHlwZSc7XG5cbnJlZ2lzdGVyTm9kZVByb2Nlc3Nvcih7XG5cbiAgbmFtZTogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG5cbiAgcGFyc2VTdGF0ZW1lbnQobm9kZSkge1xuICAgIC8vIEhhbmRsZSBub2RlLmlkIGhlcmUsIHNpbmNlIFBhdHRlcm5zIGFyZW4ndCAqcXVpdGUqIGZ1bGwgcnVsZXNcbiAgICBzd2l0Y2gobm9kZS5pZC50eXBlKSB7XG4gICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgaWYgKCFub2RlLmluaXQpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihub2RlLCAnVmFyaWFibGUgZGVjbGFyYXRpb25zIG11c3QgaGF2ZSBhbiBpbml0aWFsaXplcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudGVyU3RhdGUoc3RhdGVzLlBBUlNJTkdfRVhQUkVTU0lPTik7XG4gICAgICAgICAgdmFyIHR5cGUgPSBwcm9jZXNzTm9kZShub2RlLmluaXQpO1xuICAgICAgICAgIGlmIChpc051bGwodHlwZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKG5vZGUsICdDYW5ub3QgaW5pdGlhbGl6ZSB2YXJpYWJsZXMgdG8gXCJudWxsXCIgYmVjYXVzZSBpdCBpcyBhbWJpZ3VvdXMuJyArXG4gICAgICAgICAgICAgICcgVHJ5IGNhc3RpbmcgbnVsbCB0byBhIG5hbWVkIHR5cGU/Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZE5hbWVkVHlwZShub2RlLmlkLm5hbWUsIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGl0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ09iamVjdFBhdHRlcm4nOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5UGF0dGVybic6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaGFuZGxlSW50ZXJuYWxFcnJvcignVW5rbm93biBwYXR0ZXJuIHR5cGUgJyArIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6ICdub3JtYWwnXG4gICAgfTtcbiAgfSxcblxuICBzY2FuKG5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xuICB9XG5cbn0pO1xuIiwiKCRfX3BsYWNlaG9sZGVyX18wID0gcmVxdWlyZSgkX19wbGFjZWhvbGRlcl9fMSksIFxuICAgICAgICAkX19wbGFjZWhvbGRlcl9fMiAmJiAkX19wbGFjZWhvbGRlcl9fMy5fX2VzTW9kdWxlICYmICRfX3BsYWNlaG9sZGVyX180IHx8IHtkZWZhdWx0OiAkX19wbGFjZWhvbGRlcl9fNX0pIl19